<!DOCTYPE HTML>
<html>

<head>
  <meta charset="UTF-8">
  <title>Underscore.js(1.8.3) 中文文档</title>
  <style type="text/css">
    html,
    body {
      height: 100%;
    }
    body {
      font-family: "微软雅黑";
    }
    body,
    ul,
    p,
    pre,
    h2 {
      margin: 0;
      padding: 0;
    }
    li {
      list-style-type: none;
    }
    a {
      text-decoration: none;
    }
    #sidebar {
      height: 100%;
      position: fixed;
      width: 230px;
      overflow-y: auto;
      box-sizing: border-box;
      background-color: #2b2f3e;
    }
    #sidebar .toc_title {
      padding: 10px;
      display: block;
      font-size: 1.2em;
      color: #879943;
      font-weight: bold;
      border-bottom: 1px solid #eee;
    }
    #sidebar .toc_title:first-child {
      border-top: 3px double #eee;
    }
    #sidebar ul {
      padding-bottom: 20px;
    }
    #sidebar ul a:link {
      color: #fff;
      line-height: 1.8em;
      display: block;
      padding-left: 25px;
    }
    #sidebar ul a:visited {
      color: #9d9e9f;
    }
    #sidebar ul a:hover {
      color: #2b2f3e;
      background-color: #eee;
    }
    #sidebar ul a:active {
      color: #00f;
    }
    .container {
      margin-left: 230px;
      margin-bottom: 50px;
    }
    .container #documentation {
      width: 85%;
      margin: 0 auto;
      padding-top: 10px;
    }
    .container h2 {
      text-align: center;
      padding: 20px;
      background-color: #E2E6F0;
      border-bottom: 5px solid #168589;
      border-radius: 10px 100px 0 0;
      margin-top: 30px;
    }
    .container p,
    .container pre {
      padding-left: 20px;
    }
    .container p {
      padding-top: 15px;
      padding-bottom: 15px;
      background-color: #E2E6F0;
      line-height: 1.5em;
      letter-spacing: 0.5px;
      color: #333;
    }
    .container p tt {
      color: #FFFFFF;
      padding: 5px 10px;
      background-color: #676C21;
      border-radius: 3px;
      margin: 0 5px;
      white-space: nowrap;
    }
    .container p i {
      color: #A90B0B;
    }
    .container p b {
      color: #9E860E;
    }
    .container p code {
      margin: 0 5px;
      color: #0D8E2C;
      background-color: #F4F2D0;
      padding: 5px 10px;
      border-radius: 3px;
    }
    .container p .alias {
      color: #888;
    }
    .container p .alias b {
      color: #A15353;
    }
    .container p[id] {
      margin-top: 50px;
    }
    .container p[id] .header {
      font-size: 1.5em;
      color: #0D8E2C;
    }
    .container h2 + p[id] {
      margin-top: 0px;
    }
    .container pre {
      padding: 20px;
      margin-top: 0;
      background-color: #272822;
      color: #fff;
    }


  </style>
</head>

<body>

  <div id="sidebar" class="interface">
    <a class="toc_title" href="#collections">

      集合(Collections)

    </a>
    <ul class="toc_section">
      <li><a href="#each">each</a></li>
      <li><a href="#map">map</a></li>
      <li><a href="#reduce">reduce</a></li>
      <li><a href="#reduceRight">reduceRight</a></li>
      <li><a href="#find">find</a></li>
      <li><a href="#filter">filter</a></li>
      <li><a href="#where">where</a></li>
      <li><a href="#findWhere">findWhere</a></li>
      <li><a href="#reject">reject</a></li>
      <li><a href="#every">every</a></li>
      <li><a href="#some">some</a></li>
      <li><a href="#contains">contains</a></li>
      <li><a href="#invoke">invoke</a></li>
      <li><a href="#pluck">pluck</a></li>
      <li><a href="#max">max</a></li>
      <li><a href="#min">min</a></li>
      <li><a href="#sortBy">sortBy</a></li>
      <li><a href="#groupBy">groupBy</a></li>
      <li><a href="#indexBy">indexBy</a></li>
      <li><a href="#countBy">countBy</a></li>
      <li><a href="#shuffle">shuffle</a></li>
      <li><a href="#sample">sample</a></li>
      <li><a href="#toArray">toArray</a></li>
      <li><a href="#size">size</a></li>
      <li><a href="#partition">partition</a></li>
    </ul>

    <a class="toc_title" href="#arrays">

      数组(Arrays)

    </a>
    <ul class="toc_section">
      <li><a href="#first">first</a></li>
      <li><a href="#initial">initial</a></li>
      <li><a href="#last">last</a></li>
      <li><a href="#rest">rest</a></li>
      <li><a href="#compact">compact</a></li>
      <li><a href="#flatten">flatten</a></li>
      <li><a href="#without">without</a></li>
      <li><a href="#union">union</a></li>
      <li><a href="#intersection">intersection</a></li>
      <li><a href="#difference">difference</a></li>
      <li><a href="#uniq">uniq</a></li>
      <li><a href="#zip">zip</a></li>
      <li><a href="#unzip">unzip</a></li>
      <li><a href="#object">object</a></li>
      <li><a href="#indexOf">indexOf</a></li>
      <li><a href="#lastIndexOf">lastIndexOf</a></li>
      <li><a href="#sortedIndex">sortedIndex</a></li>
      <li><a href="#findIndex">findIndex</a></li>
      <li><a href="#findLastIndex">findLastIndex</a></li>
      <li><a href="#range">range</a></li>
    </ul>

    <a class="toc_title" href="#functions">

      函数(Functions)

    </a>
    <ul class="toc_section">
      <li><a href="#bind">bind</a></li>
      <li><a href="#bindAll">bindAll</a></li>
      <li><a href="#partial">partial</a></li>
      <li><a href="#memoize">memoize</a></li>
      <li><a href="#delay">delay</a></li>
      <li><a href="#defer">defer</a></li>
      <li><a href="#throttle">throttle</a></li>
      <li><a href="#debounce">debounce</a></li>
      <li><a href="#once">once</a></li>
      <li><a href="#after">after</a></li>
      <li><a href="#before">before</a></li>
      <li><a href="#wrap">wrap</a></li>
      <li><a href="#negate">negate</a></li>
      <li><a href="#compose">compose</a></li>
    </ul>

    <a class="toc_title" href="#objects">

      对象(Objects)

    </a>
    <ul class="toc_section">
      <li><a href="#keys">keys</a></li>
      <li><a href="#allKeys">allKeys</a></li>
      <li><a href="#values">values</a></li>
      <li><a href="#mapObject">mapObject</a></li>
      <li><a href="#pairs">pairs</a></li>
      <li><a href="#invert">invert</a></li>
      <li><a href="#create">create</a></li>
      <li><a href="#object-functions">functions</a></li>
      <li><a href="#findKey">findKey</a></li>
      <li><a href="#extend">extend</a></li>
      <li><a href="#extendOwn">extendOwn</a></li>
      <li><a href="#pick">pick</a></li>
      <li><a href="#omit">omit</a></li>
      <li><a href="#defaults">defaults</a></li>
      <li><a href="#clone">clone</a></li>
      <li><a href="#tap">tap</a></li>
      <li><a href="#has">has</a></li>
      <li><a href="#matcher">matcher</a></li>
      <li><a href="#property">property</a></li>
      <li><a href="#propertyOf">propertyOf</a></li>
      <li><a href="#isEqual">isEqual</a></li>
      <li><a href="#isMatch">isMatch</a></li>
      <li><a href="#isEmpty">isEmpty</a></li>
      <li><a href="#isElement">isElement</a></li>
      <li><a href="#isArray">isArray</a></li>
      <li><a href="#isObject">isObject</a></li>
      <li><a href="#isArguments">isArguments</a></li>
      <li><a href="#isFunction">isFunction</a></li>
      <li><a href="#isString">isString</a></li>
      <li><a href="#isNumber">isNumber</a></li>
      <li><a href="#isFinite">isFinite</a></li>
      <li><a href="#isBoolean">isBoolean</a></li>
      <li><a href="#isDate">isDate</a></li>
      <li><a href="#isRegExp">isRegExp</a></li>
      <li><a href="#isNaN">isNaN</a></li>
      <li><a href="#isNull">isNull</a></li>
      <li><a href="#isUndefined">isUndefined</a></li>
    </ul>

    <a class="toc_title" href="#utility">

      实用功能(Utility)

    </a>
    <ul class="toc_section">
      <li><a href="#noConflict">noConflict</a></li>
      <li><a href="#identity">identity</a></li>
      <li><a href="#constant">constant</a></li>
      <li><a href="#noop">noop</a></li>
      <li><a href="#times">times</a></li>
      <li><a href="#random">random</a></li>
      <li><a href="#mixin">mixin</a></li>
      <li><a href="#iteratee">iteratee</a></li>
      <li><a href="#uniqueId">uniqueId</a></li>
      <li><a href="#escape">escape</a></li>
      <li><a href="#unescape">unescape</a></li>
      <li><a href="#result">result</a></li>
      <li><a href="#now">now</a></li>
      <li><a href="#template">template</a></li>
    </ul>

    <a class="toc_title" href="#chaining">

      链式语法(Chaining)

    </a>
    <ul class="toc_section">
      <li><a href="#chain">chain</a></li>
      <li><a href="#value">value</a></li>
    </ul>
  </div>

  <div class="container">
    <div id="documentation">
      <h2 id="collections">集合函数  (数组 或对象)</h2>

      <p id="each">
        <b class="header">each</b><code>_.each(list, iteratee, [context])</code>
        <span class="alias">Alias: <b>forEach</b></span>
        <br> 遍历

        <b>list</b>中的所有元素，按顺序用遍历输出每个元素。如果传递了<b>context</b>参数，则把<b>iteratee</b>绑定到<b>context</b>对象上。每次调用<b>iteratee</b>都会传递三个参数：<tt>(element, index, list)</tt>。如果<b>list</b>是个JavaScript对象，<b>iteratee</b>的参数是 <tt>(value, key, list)</tt>)。返回<b>list</b>以方便链式调用。（注：如果存在原生的<b>forEach</b>方法，Underscore就使用它代替。）
      </p>
      <pre>
        _.each([1, 2, 3], alert);

        =&gt; alerts each number in turn...

        _.each({one: 1, two: 2, three: 3}, alert);

        =&gt; alerts each number value in turn...
      </pre>

      <p>
        <i>

          注意：集合函数能在数组，对象，和类数组对象，比如</i><tt>arguments</tt>, <tt>NodeList</tt><i>和类似的数据类型上正常工作。 但是它通过<a href="http://zh.wikipedia.org/zh-cn/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank">鸭子类型</a>工作，所以要避免传递一个不固定<tt>length</tt>属性的对象（注：对象或数组的长度（length）属性要固定的）。每个循环不能被破坏 - 打破， 使用<b>_.find</b>代替，这也是很好的注意。

        </i>
      </p>

      <p id="map">
        <b class="header">map</b><code>_.map(list, iteratee, [context])</code>
        <span class="alias">Alias: <b>collect</b></span>
        <br> 通过转换函数(
        <b>iteratee</b>迭代器)映射列表中的每个值产生价值的新数组。<tt>iteratee</tt>传递三个参数：<tt>value</tt>，然后是迭代 <tt>index</tt>(或 <tt>key</tt> 注：如果<b>list</b>是个JavaScript对象是，这个参数就是<tt>key</tt>)，最后一个是引用指向整个<tt>list</tt>。
      </p>
      <pre>_.map([1, 2, 3], function(num){ return num * 3; });

        =&gt; [3, 6, 9]

        _.map({one: 1, two: 2, three: 3}, function(num, key){ return num * 3; });

        =&gt; [3, 6, 9]

        _.map([[1, 2], [3, 4]], _.first);

        =&gt; [1, 3]
      </pre>

      <p id="reduce">
        <b class="header">reduce</b><code>_.reduce(list, iteratee, [memo], [context])</code>
        <span class="alias">Aliases: <b>inject, foldl</b></span>
        <br> 别名为 <b>inject</b> 和 <b>foldl</b>, <b>reduce</b>方法把<b>list</b>中元素归结为一个单独的数值。<b>Memo</b>是reduce函数的初始值，reduce的每一步都需要由<b>iteratee</b>返回。这个迭代传递4个参数：<tt>memo</tt>,<tt>value</tt> 和 迭代的<tt>index</tt>（或者 key）和最后一个引用的整个 <tt>list</tt>。
      </p>
      <p>
        如果没有<b>memo</b>传递给<b>reduce</b>的初始调用，<b>iteratee</b>不会被列表中的第一个元素调用。第一个元素将取代 传递给列表中下一个元素调用<b>iteratee</b>的<b>memo</b>参数。
      </p>
      <pre>var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);

        =&gt; 6


      </pre>

      <p id="reduceRight">
        <b class="header">reduceRight</b><code>_.reduceRight(list, iteratee, memo, [context])</code>
        <span class="alias">Alias: <b>foldr</b></span>
        <br>
        <b>reducRight</b>是从右侧开始组合的元素的<b>reduce</b>函数，如果存在JavaScript 1.8版本的<b>reduceRight</b>，则用其代替。<b>Foldr</b>在javascript中不像其它有懒计算的语言那么有用（注：lazy evaluation：一种求值策略，只有当表达式的值真正需要时才对表达式进行计算）。

      </p>
      <pre>var list = [[0, 1], [2, 3], [4, 5]];

        var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);

        =&gt; [4, 5, 2, 3, 0, 1]


      </pre>

      <p id="find">
        <b class="header">find</b><code>_.find(list, predicate, [context])</code>
        <span class="alias">Alias: <b>detect</b></span>
        <br> 在
        <b>list</b>中逐项查找，返回第一个通过<b>predicate</b>迭代函数真值检测的元素值，如果没有值传递给测试迭代器将返回<code>undefined</code>。 如果找到匹配的元素，函数将立即返回，不会遍历整个list。

      </p>
      <pre>var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });

        =&gt; 2


      </pre>

      <p id="filter">
        <b class="header">filter</b><code>_.filter(list, predicate, [context])</code>
        <span class="alias">Alias: <b>select</b></span>
        <br> 遍历
        <b>list</b>中的每个值，返回包含所有通过<b>predicate</b>真值检测的元素值。（注：如果存在原生<b>filter</b>方法，则用原生的<b>filter</b>方法。）
      </p>
      <pre>var evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });

        =&gt; [2, 4, 6]


      </pre>

      <p id="where">
        <b class="header">where</b><code>_.where(list, properties)</code>
        <br> 遍历
        <b>list</b>中的每一个值，返回一个数组，这个数组包含<b>properties</b>所列出的属性的所有的 键 - 值对。
      </p>
      <pre>_.where(listOfPlays, {author: "Shakespeare", year: 1611});

        =&gt; [{title: "Cymbeline", author: "Shakespeare", year: 1611},

        {title: "The Tempest", author: "Shakespeare", year: 1611}]


      </pre>

      <p id="findWhere">
        <b class="header">findWhere</b><code>_.findWhere(list, properties)</code>
        <br> 遍历整个
        <b>list</b>，返回匹配 <b>properties</b>参数所列出的所有 键 - 值 对的第一个值。
      </p>
      <p>
        如果没有找到匹配的属性，或者<b>list</b>是空的，那么将返回<i>undefined</i>。
      </p>
      <pre>_.findWhere(publicServicePulitzers, {newsroom: "The New York Times"});

        =&gt; {year: 1918, newsroom: "The New York Times",

        reason: "For its public service in publishing in full so many official reports,

        documents and speeches by European statesmen relating to the progress and

        conduct of the war."}


      </pre>

      <p id="reject">
        <b class="header">reject</b><code>_.reject(list, predicate, [context])</code>
        <br> 返回
        <b>list</b>中没有通过<b>predicate</b>真值检测的元素集合，与<b>filter</b>相反。
      </p>
      <pre>var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });

        =&gt; [1, 3, 5]


      </pre>

      <p id="every">
        <b class="header">every</b><code>_.every(list, [predicate], [context])</code>
        <span class="alias">Alias: <b>all</b></span>
        <br> 如果

        <b>list</b>中的所有元素都通过<b>predicate</b>的真值检测就返回<i>true</i>。（注：如果存在原生的<b>every</b>方法，就使用原生的<b>every</b>。）

      </p>
      <pre>_.every([true, 1, null, 'yes'], _.identity);

        =&gt; false


      </pre>

      <p id="some">
        <b class="header">some</b><code>_.some(list, [predicate], [context])</code>
        <span class="alias">Alias: <b>any</b></span>
        <br> 如果
        <b>list</b>中有任何一个元素通过 <b>predicate</b> 的真值检测就返回<i>true</i>。一旦找到了符合条件的元素, 就直接中断对list的遍历. （注：如果存在原生的<b>some</b>方法，就使用原生的<b>some</b>。）
      </p>
      <pre>_.some([null, 0, 'yes', false]);

        =&gt; true


      </pre>

      <p id="contains">
        <b class="header">contains</b><code>_.contains(list, value, [fromIndex])</code>
        <span class="alias">Alias: <b>includes</b></span>
        <br> 如果
        <b>list</b>包含指定的<b>value</b>则返回<i>true</i>（注：使用===检测）。如果<b>list</b> 是数组，内部使用<b>indexOf</b>判断。使用<b>fromIndex</b>来给定开始检索的索引位置。
      </p>
      <pre>_.contains([1, 2, 3], 3);

        =&gt; true


      </pre>

      <p id="invoke">
        <b class="header">invoke</b><code>_.invoke(list, methodName, *arguments)</code>
        <br> 在
        <b>list</b>的每个元素上执行<b>methodName</b>方法。 任何传递给
        <b>invoke</b>的额外参数，<b>invoke</b>都会在调用<b>methodName</b>方法的时候传递给它。
      </p>
      <pre>_.invoke([[5, 1, 7], [3, 2, 1]], 'sort');

        =&gt; [[1, 5, 7], [1, 2, 3]]


      </pre>

      <p id="pluck">
        <b class="header">pluck</b><code>_.pluck(list, propertyName)</code>
        <br>
        <b>pluck</b>也许是<b>map</b>最常使用的用例模型的简化版本，即萃取数组对象中某属性值，返回一个数组。
      </p>
      <pre>var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];

        _.pluck(stooges, 'name');

        =&gt; ["moe", "larry", "curly"]


      </pre>

      <p id="max">
        <b class="header">max</b><code>_.max(list, [iteratee], [context])</code>
        <br> 返回
        <b>list</b>中的最大值。如果传递<b>iteratee</b>参数，<b>iteratee</b>将作为<b>list</b>中每个值的排序依据。如果<b>list</b>为空，将返回<i>-Infinity</i>，所以你可能需要事先用<a href="#isEmpty">isEmpty</a>检查 <b>list</b> 。
      </p>
      <pre>var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];

        _.max(stooges, function(stooge){ return stooge.age; });

        =&gt; {name: 'curly', age: 60};


      </pre>

      <p id="min">
        <b class="header">min</b><code>_.min(list, [iteratee], [context])</code>
        <br> 返回
        <b>list</b>中的最小值。如果传递<b>iteratee</b>参数，<b>iteratee</b>将作为<b>list</b>中每个值的排序依据。如果<b>list</b>为空，将返回<i>-Infinity</i>，所以你可能需要事先用<a href="#isEmpty">isEmpty</a>检查 <b>list</b> 。
      </p>
      <pre>var numbers = [10, 5, 100, 2, 1000];

        _.min(numbers);

        =&gt; 2


      </pre>

      <p id="sortBy">
        <b class="header">sortBy</b><code>_.sortBy(list, iteratee, [context])</code>
        <br> 返回一个排序后的
        <b>list</b>拷贝副本。如果传递<b>iteratee</b>参数，<b>iteratee</b>将作为<b>list</b>中每个值的排序依据。迭代器也可以是字符串的属性的名称进行排序的(比如 <tt>length</tt>)。
      </p>
      <pre>_.sortBy([1, 2, 3, 4, 5, 6], function(num){ return Math.sin(num); });

        =&gt; [5, 4, 6, 3, 1, 2]



        var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];

        _.sortBy(stooges, 'name');

        =&gt; [{name: 'curly', age: 60}, {name: 'larry', age: 50}, {name: 'moe', age: 40}];


      </pre>
      <p id="groupBy">
        <b class="header">groupBy</b><code>_.groupBy(list, iteratee, [context])</code>
        <br> 把一个集合分组为多个集合，通过 <b>iterator</b> 返回的结果进行分组. 如果 <b>iterator</b> 是一个字符串而不是函数, 那么将使用 <b>iterator</b> 作为各元素的属性名来对比进行分组.
      </p>
      <pre>_.groupBy([1.3, 2.1, 2.4], function(num){ return Math.floor(num); });

        =&gt; {1: [1.3], 2: [2.1, 2.4]}



        _.groupBy(['one', 'two', 'three'], 'length');

        =&gt; {3: ["one", "two"], 5: ["three"]}


      </pre>

      <p id="indexBy">
        <b class="header">indexBy</b><code>_.indexBy(list, iteratee, [context])</code>
        <br> 给定一个
        <b>list</b>，和 一个用来返回一个在列表中的每个元素键 的<b>iterator</b> 函数（或属性名）， 返回一个每一项索引的对象。和
        <a href="#groupBy">groupBy</a>非常像，但是当你知道你的键是唯一的时候可以使用<b>indexBy</b> 。

      </p>
      <pre>
        var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];

          _.indexBy(stooges, 'age');

          =&gt; {

          "40": {name: 'moe', age: 40},

          "50": {name: 'larry', age: 50},

          "60": {name: 'curly', age: 60}

        }


      </pre>

      <p id="countBy">
        <b class="header">countBy</b><code>_.countBy(list, iteratee, [context])</code>
        <br> 排序一个列表组成一个组，并且返回各组中的对象的数量的计数。类似
        <tt>groupBy</tt>，但是不是返回列表的值，而是返回在该组中值的数目。

      </p>
      <pre>_.countBy([1, 2, 3, 4, 5], function(num) {

        return num % 2 == 0 ? 'even': 'odd';

      });

      =&gt; {odd: 3, even: 2}


      </pre>

      <p id="shuffle">
        <b class="header">shuffle</b><code>_.shuffle(list)</code>
        <br> 返回一个随机乱序的 <b>list</b> 副本, 使用
        <a href="http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher-Yates shuffle</a> 来进行随机乱序.
      </p>
      <pre>_.shuffle([1, 2, 3, 4, 5, 6]);

        =&gt; [4, 1, 6, 3, 5, 2]


      </pre>

      <p id="sample">
        <b class="header">sample</b><code>_.sample(list, [n])</code>
        <br> 从 <b>list</b>中产生一个随机样本。传递一个数字表示从<b>list</b>中返回<b>n</b>个随机元素。否则将返回一个单一的随机项。
      </p>
      <pre>_.sample([1, 2, 3, 4, 5, 6]);

        =&gt; 4



        _.sample([1, 2, 3, 4, 5, 6], 3);

        =&gt; [1, 6, 2]


      </pre>

      <p id="toArray">
        <b class="header">toArray</b><code>_.toArray(list)</code>
        <br> 把
        <b>list</b>(任何可以迭代的对象)转换成一个数组，在转换 <b>arguments</b> 对象时非常有用。
      </p>
      <pre>(function(){ return _.toArray(arguments).slice(1); })(1, 2, 3, 4);

        =&gt; [2, 3, 4]


      </pre>

      <p id="size">
        <b class="header">size</b><code>_.size(list)</code>
        <br> 返回
        <b>list</b>的长度。
      </p>
      <pre>_.size({one: 1, two: 2, three: 3});

        =&gt; 3


      </pre>

      <p id="partition">
        <b class="header">partition</b><code>_.partition(array, predicate)</code>
        <br> 拆分一个数组（
        <b>array</b>）为两个数组： &nbsp;第一个数组其元素都满足
        <b>predicate</b>迭代函数， 而第二个的所有元素均不能满足<b>predicate</b>迭代函数。
      </p>
      <pre>_.partition([0, 1, 2, 3, 4, 5], isOdd);

        =&gt; [[1, 3, 5], [0, 2, 4]]


      </pre>

      <h2 id="arrays">数组函数（Array Functions）</h2>

      <p>
        <i>注： <b>arguments（参数）</b> 对象将在所有数组函数中工作 。然而, Underscore 函数的设计并不只是针对稀疏（"sparse" ）数组的.</i>
      </p>

      <p id="first">
        <b class="header">first</b><code>_.first(array, [n])</code>
        <span class="alias">Alias: <b>head</b>, <b>take</b></span>
        <br> 返回
        <b>array（数组）</b>的第一个元素。传递 <b>n</b>参数将返回数组中从第一个元素开始的<b>n</b>个元素（注：返回数组中前 <b>n</b> 个元素.）。
      </p>
      <pre>_.first([5, 4, 3, 2, 1]);

        =&gt; 5


      </pre>

      <p id="initial">
        <b class="header">initial</b><code>_.initial(array, [n])</code>
        <br> 返回数组中除了最后一个元素外的其他全部元素。 在arguments对象上特别有用。传递 <b>n</b>参数将从结果中排除从最后一个开始的<b>n</b>个元素（注：排除数组后面的 <b>n</b> 个元素）。

      </p>
      <pre>_.initial([5, 4, 3, 2, 1]);

        =&gt; [5, 4, 3, 2]


      </pre>

      <p id="last">
        <b class="header">last</b><code>_.last(array, [n])</code>
        <br> 返回
        <b>array（数组）</b>的最后一个元素。传递 <b>n</b>参数将返回数组中从最后一个元素开始的<b>n</b>个元素（注：返回数组里的后面的<b>n</b>个元素）。
      </p>
      <pre>_.last([5, 4, 3, 2, 1]);

        =&gt; 1


      </pre>

      <p id="rest">
        <b class="header">rest</b><code>_.rest(array, [index])</code>
        <span class="alias">Alias: <b>tail, drop</b></span>
        <br> 返回数组中除了第一个元素外的其他全部元素。传递 <b>index</b> 参数将返回从<b>index</b>开始的剩余所有元素 。
      </p>
      <pre>_.rest([5, 4, 3, 2, 1]);

        =&gt; [4, 3, 2, 1]


      </pre>

      <p id="compact">
        <b class="header">compact</b><code>_.compact(array)</code>
        <br> 返回一个除去所有
        <i>false</i>值的 <b>array</b>副本。 在javascript中, <i>false</i>, <i>null</i>, <i>0</i>, <i>""</i>,
        <i>undefined</i> 和 <i>NaN</i> 都是<i>false</i>值.
      </p>
      <pre>_.compact([0, 1, false, 2, '', 3]);

        =&gt; [1, 2, 3]


      </pre>

      <p id="flatten">
        <b class="header">flatten</b><code>_.flatten(array, [shallow])</code>
        <br> 将一个嵌套多层的数组 <b>array（数组）</b> (嵌套可以是任何层数)转换为只有一层的数组。 如果你传递 <b>shallow</b>参数，数组将只减少一维的嵌套。
      </p>
      <pre>_.flatten([1, [2], [3, [[4]]]]);

        =&gt; [1, 2, 3, 4];



        _.flatten([1, [2], [3, [[4]]]], true);

        =&gt; [1, 2, 3, [[4]]];


      </pre>

      <p id="without">
        <b class="header">without</b><code>_.without(array, *values)</code>
        <br> 返回一个删除所有
        <b>values</b>值后的 <b>array</b>副本。（注：使用<i>===</i>表达式做相等测试。）
      </p>
      <pre>_.without([1, 2, 1, 0, 3, 1, 4], 0, 1);

        =&gt; [2, 3, 4]


      </pre>

      <p id="union">
        <b class="header">union</b><code>_.union(*arrays)</code>
        <br> 返回传入的 <b>arrays（数组）</b>并集：按顺序返回，返回数组的元素是唯一的，可以传入一个或多个 <b>arrays（数组）</b>。

      </p>
      <pre>_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);

        =&gt; [1, 2, 3, 101, 10]


      </pre>

      <p id="intersection">
        <b class="header">intersection</b><code>_.intersection(*arrays)</code>
        <br> 返回传入 <b>arrays（数组）</b>交集。结果中的每个值是存在于传入的每个<b>arrays（数组）</b>里。
      </p>
      <pre>_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);

        =&gt; [1, 2]


      </pre>

      <p id="difference">
        <b class="header">difference</b><code>_.difference(array, *others)</code>
        <br> 类似于
        <b>without</b>，但返回的值来自<b>array</b>参数数组，并且不存在于<b>other</b> 数组.
      </p>
      <pre>_.difference([1, 2, 3, 4, 5], [5, 2, 10]);

        =&gt; [1, 3, 4]


      </pre>

      <p id="uniq">
        <b class="header">uniq</b><code>_.uniq(array, [isSorted], [iteratee])</code>
        <span class="alias">Alias: <b>unique</b></span>
        <br> 返回 <b>array</b>去重后的副本, 使用 <i>===</i> 做相等测试. 如果您确定 <b>array</b> 已经排序, 那么给 <b>isSorted</b> 参数传递 <i>true</i>值, 此函数将运行的更快的算法. 如果要处理对象元素, 传递 <b>iteratee</b>函数来获取要对比的属性.
      </p>
      <pre>_.uniq([1, 2, 1, 3, 1, 4]);

        =&gt; [1, 2, 3, 4]


      </pre>

      <p id="zip">
        <b class="header">zip</b><code>_.zip(*arrays)</code>
        <br> 将 每个<b>arrays</b>中相应位置的值合并在一起。在合并分开保存的数据时很有用. 如果你用来处理矩阵嵌套数组时, <tt>_.zip.apply</tt> 可以做类似的效果。
      </p>
      <pre>_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);

        =&gt; [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]

      </pre>

      <p id="unzip">
        <b class="header">unzip</b><code>_.unzip(*arrays)</code>
        <br> 与
        <a href="#zip">zip</a>功能相反的函数，给定若干<b>arrays</b>，返回一串联的新数组，其第一元素个包含所有的输入数组的第一元素，其第二包含了所有的第二元素，依此类推。通过<tt>apply</tt>用于传递数组的数组。
      </p>
      <pre>_.unzip(["moe", 30, true], ["larry", 40, false], ["curly", 50, false]);

        =&gt; [['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]]


      </pre>

      <p id="object">
        <b class="header">object</b><code>_.object(list, [values])</code>
        <br> 将数组转换为对象。传递任何一个单独
        <tt>[key, value]</tt>对的列表，或者一个键的列表和一个值得列表。 如果存在重复键，最后一个值将被返回。
      </p>
      <pre>_.object(['moe', 'larry', 'curly'], [30, 40, 50]);

        =&gt; {moe: 30, larry: 40, curly: 50}



        _.object([['moe', 30], ['larry', 40], ['curly', 50]]);

        =&gt; {moe: 30, larry: 40, curly: 50}


      </pre>

      <p id="indexOf">
        <b class="header">indexOf</b><code>_.indexOf(array, value, [isSorted])</code>
        <br> 返回
        <b>value</b>在该 <b>array</b> 中的索引值，如果<b>value</b>不存在 <b>array</b>中就返回<i>-1</i>。使用原生的<b>indexOf</b> 函数，除非它失效。如果您正在使用一个大数组，你知道数组已经排序，传递<tt>true</tt>给<b>isSorted</b>将更快的用二进制搜索..,或者，传递一个数字作为第三个参数，为了在给定的索引的数组中寻找第一个匹配值。
      </p>
      <pre>_.indexOf([1, 2, 3], 2);

        =&gt; 1


      </pre>

      <p id="lastIndexOf">
        <b class="header">lastIndexOf</b><code>_.lastIndexOf(array, value, [fromIndex])</code>
        <br> 返回
        <b>value</b>在该 <b>array</b> 中的从最后开始的索引值，如果<b>value</b>不存在 <b>array</b>中就返回<i>-1</i>。如果支持原生的<b>lastIndexOf</b>，将使用原生的<b>lastIndexOf</b>函数。传递<b>fromIndex</b>将从你给定的索性值开始搜索。
      </p>
      <pre>_.lastIndexOf([1, 2, 3, 1, 2, 3], 2);

        =&gt; 4


      </pre>

      <p id="sortedIndex">
        <b class="header">sortedIndex</b><code>_.sortedIndex(list, value, [iteratee], [context])</code>
        <br> 使用二分查找确定
        <b>value</b>在<b>list</b>中的位置序号，<b>value</b>按此序号插入能保持<b>list</b>原有的排序。如果提供<b>iterator</b>函数，<b>iterator</b>将作为list排序的依据，包括你传递的<b>value</b> 。<b>iterator</b>也可以是字符串的属性名用来排序(比如<tt>length</tt>)。
      </p>
      <pre>_.sortedIndex([10, 20, 30, 40, 50], 35);

        =&gt; 3



        var stooges = [{name: 'moe', age: 40}, {name: 'curly', age: 60}];

        _.sortedIndex(stooges, {name: 'larry', age: 50}, 'age');

        =&gt; 1


      </pre>

      <p id="findIndex">
        <b class="header">findIndex</b><code>_.findIndex(array, predicate, [context])</code>
        <br> 类似于
        <a href="#indexOf"><tt>_.indexOf</tt></a>，当<strong>predicate</strong>通过真检查时，返回第一个索引值；否则返回<i>-1</i>。
      </p>
      <pre>
        _.findIndex([4, 6, 8, 12], isPrime);

        =&gt; -1 // not found

        _.findIndex([4, 6, 7, 12], isPrime);

        =&gt; 2


      </pre>

      <p id="findLastIndex">
        <b class="header">findLastIndex</b><code>_.findLastIndex(array, predicate, [context])</code>
        <br> 和
        <a href="#findIndex"><tt>_.findIndex</tt></a>类似，但反向迭代数组，当<strong>predicate</strong>通过真检查时，最接近末端的索引值将被返回。

      </p>
      <pre>
        var users = [{'id': 1, 'name': 'Bob', 'last': 'Brown'},

        {'id': 2, 'name': 'Ted', 'last': 'White'},

        {'id': 3, 'name': 'Frank', 'last': 'James'},

        {'id': 4, 'name': 'Ted', 'last': 'Jones'}];

        _.findLastIndex(users, {

        name: 'Ted'

      });

      =&gt; 3


      </pre>

      <p id="range">
        <b class="header">range</b><code>_.range([start], stop, [step])</code>
        <br> 一个用来创建整数灵活编号的列表的函数，便于
        <tt>each</tt> 和 <tt>map</tt>循环。如果省略<b>start</b>则默认为 <i>0</i>；<b>step</b> 默认为 <i>1</i>.返回一个从<b>start</b> 到<b>stop</b>的整数的列表，用<b>step</b>来增加 （或减少）独占。值得注意的是，如果<b>stop</b>值在<b>start</b>前面（也就是<b>stop</b>值小于<b>start</b>值），那么值域会被认为是零长度，而不是负增长。-如果你要一个负数的值域
        ，请使用负数
        <b>step</b>.
      </p>
      <pre>
        _.range(10);

        =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

        _.range(1, 11);

        =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

        _.range(0, 30, 5);

        =&gt; [0, 5, 10, 15, 20, 25]

        _.range(0, -10, -1);

        =&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]

        _.range(0);

        =&gt; []


      </pre>

      <h2 id="functions">与函数有关的函数（Function (uh, ahem) Functions）</h2>

      <p id="bind">
        <b class="header">bind</b><code>_.bind(function, object, *arguments)</code>
        <br> 绑定函数 <b>function</b> 到对象 <b>object</b> 上, 也就是无论何时调用函数, 函数里的 <i>this</i> 都指向这个 <b>object</b>.任意可选参数 <b>arguments</b> 可以传递给函数 <b>function</b> , 可以填充函数所需要的参数,这也被称为 <b>partial application</b>。对于没有结合上下文的<b>partial application</b>绑定，请使用<a href="#partial">partial</a>。
        <br>(注：partial application翻译成“部分应用”或者“偏函数应用”。partial application可以被描述为一个函数，它接受一定数目的参数，绑定值到一个或多个这些参数，并返回一个新的函数，这个返回函数只接受剩余未绑定值的参数。参见：<a href="http://en.wikipedia.org/wiki/Partial_application" target="_blank">http://en.wikipedia.org/wiki/Partial_application</a>。感谢
        <a href="http://weibo.com/u/2654434300" target="_blank">@一任风月忆秋年</a>的建议)。
      </p>
      <pre>var func = function(greeting){ return greeting + ': ' + this.name };

        func = _.bind(func, {name: 'moe'}, 'hi');

        func();

        =&gt; 'hi: moe'


      </pre>

      <p id="bindAll">
        <b class="header">bindAll</b><code>_.bindAll(object, *methodNames)</code>
        <br> 把
        <b>methodNames</b>参数指定的一些方法绑定到<b>object</b>上，这些方法就会在对象的上下文环境中执行。绑定函数用作事件处理函数时非常便利，否则函数被调用时<i>this</i>一点用也没有。<b>methodNames</b>参数是必须的。
      </p>
      <pre>
        var buttonView = {

        label  : 'underscore',

        onClick: function(){ alert('clicked: ' + this.label); },

        onHover: function(){ console.log('hovering: ' + this.label); }

      };

      _.bindAll(buttonView, 'onClick', 'onHover');

      // When the button is clicked, this.label will have the correct value.

      jQuery('#underscore_button').bind('click', buttonView.onClick);


      </pre>

      <p id="partial">
        <b class="header">partial</b><code>_.partial(function, *arguments)</code>
        <br> 局部应用一个函数填充在任意个数的 <b>arguments</b>，<i>不</i>改变其动态<tt>this</tt>值。和<a href="#bind">bind</a>方法很相近。你可以传递<tt>_</tt> 给<b>arguments</b>列表来指定一个不预先填充，但在调用时提供的参数。
      </p>
      <pre>
        var subtract = function(a, b) { return b - a; };

        sub5 = _.partial(subtract, 5);

        sub5(20);

        =&gt; 15



        // Using a placeholder

        subFrom20 = _.partial(subtract, _, 20);

        subFrom20(5);

        =&gt; 15


      </pre>

      <p id="memoize">
        <b class="header">memoize</b><code>_.memoize(function, [hashFunction])</code>
        <br> Memoizes方法可以缓存某函数的计算结果。对于耗时较长的计算是很有帮助的。如果传递了 <b>hashFunction</b> 参数，就用 <b>hashFunction</b> 的返回值作为key存储函数的计算结果。<b>hashFunction</b> 默认使用function的第一个参数作为key。memoized值的缓存可作为返回函数的<tt>cache</tt>属性。
      </p>
      <pre>
        var fibonacci = _.memoize(function(n) {

        return n &lt; 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);

      });


      </pre>

      <p id="delay">
        <b class="header">delay</b><code>_.delay(function, wait, *arguments)</code>
        <br> 类似
        <b>setTimeout</b>，等待<b>wait</b>毫秒后调用<b>function</b>。如果传递可选的参数<b>arguments</b>，当函数<b>function</b>执行时， <b>arguments</b> 会作为参数传入。
      </p>
      <pre>var log = _.bind(console.log, console);

        _.delay(log, 1000, 'logged later');

        =&gt; 'logged later' // Appears after one second.


      </pre>

      <p id="defer">
        <b class="header">defer</b><code>_.defer(function, *arguments)</code>
        <br> 延迟调用
        <b>function</b>直到当前调用栈清空为止，类似使用延时为0的<b>setTimeout</b>方法。对于执行开销大的计算和无阻塞UI线程的HTML渲染时候非常有用。 如果传递
        <b>arguments</b>参数，当函数<b>function</b>执行时， <b>arguments</b> 会作为参数传入。
      </p>
      <pre>_.defer(function(){ alert('deferred'); });

        // Returns from the function before the alert runs.


      </pre>

      <p id="throttle">
        <b class="header">throttle</b><code>_.throttle(function, wait, [options])</code>
        <br> 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，最多每隔 <b>wait</b>毫秒调用一次该函数。对于想控制一些触发频率较高的事件有帮助。（注：详见：<a href="http://www.css88.com/archives/5256" target="_blank">javascript函数的throttle和debounce</a>）
      </p>
      <p>
        默认情况下，<b>throttle</b>将在你调用的第一时间尽快执行这个<b>function</b>，并且，如果你在<b>wait</b>周期内调用任意次数的函数，都将尽快的被覆盖。如果你想禁用第一次首先执行的话，传递<tt>{leading: false}</tt>，还有如果你想禁用最后一次执行的话，传递<tt>{trailing: false}</tt>。
      </p>
      <pre>var throttled = _.throttle(updatePosition, 100);

        $(window).scroll(throttled);


      </pre>

      <p id="debounce">
        <b class="header">debounce</b><code>_.debounce(function, wait, [immediate])</code>
        <br> 返回 <b>function</b> 函数的防反跳版本, 将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 <b>wait</b> 毫秒之后. 对于必须在一些输入（多是一些用户操作）停止到达
        <i>之后</i>执行的行为有帮助。 例如: 渲染一个Markdown格式的评论预览, 当窗口停止改变大小之后重新计算布局, 等等.
      </p>

      <p>
        传参 <b>immediate</b> 为 <tt>true</tt>， <b>debounce</b>会在 <b>wait</b> 时间间隔的开始调用这个函数 。（注：并且在 waite 的时间之内，不会再次调用。）在类似不小心点了提交按钮两下而提交了两次的情况下很有用。 （感谢
        <a href="http://weibo.com/u/1768962955" target="_blank">@ProgramKid </a> 的翻译建议）
      </p>

      <pre>var lazyLayout = _.debounce(calculateLayout, 300);

        $(window).resize(lazyLayout);


      </pre>

      <p id="once">
        <b class="header">once</b><code>_.once(function)</code>
        <br> 创建一个只能调用一次的函数。重复调用改进的方法也没有效果，只会返回第一次执行时的结果。 作为初始化函数使用时非常有用, 不用再设一个boolean值来检查是否已经初始化完成.
      </p>
      <pre>var initialize = _.once(createApplication);

        initialize();

        initialize();

        // Application is only created once.


      </pre>

      <p id="after">
        <b class="header">after</b><code>_.after(count, function)</code>
        <br> 创建一个函数, 只有在运行了 <b>count</b> 次之后才有效果. 在处理同组异步请求返回结果时, 如果你要确保同组里所有异步请求完成之后才 执行这个函数, 这将非常有用。

      </p>
      <pre>
        var renderNotes = _.after(notes.length, render);

        _.each(notes, function(note) {

        note.asyncSave({success: renderNotes});

      });

      // renderNotes is run once, after all notes have saved.


      </pre>

      <p id="before">
        <b class="header">before</b><code>_.before(count, function)</code>
        <br> 创建一个函数,调用不超过
        <b>count</b> 次。 当<b>count</b>已经达到时，最后一个函数调用的结果将被记住并返回。
      </p>
      <pre>var monthlyMeeting = _.before(3, askForRaise);

        monthlyMeeting();

        monthlyMeeting();

        monthlyMeeting();

        // the result of any subsequent calls is the same as the second call


      </pre>

      <p id="wrap">
        <b class="header">wrap</b><code>_.wrap(function, wrapper)</code>
        <br> 将第一个函数 <b>function</b> 封装到函数 <b>wrapper</b> 里面, 并把函数 <b>function</b> 作为第一个参数传给 <b>wrapper</b>. 这样可以让 <b>wrapper</b> 在 <b>function</b> 运行之前和之后 执行代码, 调整参数然后附有条件地执行.
      </p>
      <pre>
        var hello = function(name) { return "hello: " + name; };

        hello = _.wrap(hello, function(func) {

        return "before, " + func("moe") + ", after";

      });

      hello();

      =&gt; 'before, hello: moe, after'


      </pre>

      <p id="negate">
        <b class="header">negate</b><code>_.negate(predicate)</code>
        <br> 返回一个新的
        <b>predicate</b>函数的否定版本。
      </p>
      <pre>var isFalsy = _.negate(Boolean);

        _.find([-2, -1, 0, 1, 2], isFalsy);

        =&gt; 0


      </pre>

      <p id="compose">
        <b class="header">compose</b><code>_.compose(*functions)</code>
        <br> 返回函数集 <b>functions</b> 组合后的复合函数, 也就是一个函数执行完之后把返回的结果再作为参数赋给下一个函数来执行. 以此类推. 在数学里, 把函数 <i>f()</i>, <i>g()</i>, 和 <i>h()</i> 组合起来可以得到复合函数 <i>f(g(h()))</i>。
      </p>
      <pre>var greet    = function(name){ return "hi: " + name; };

        var exclaim  = function(statement){ return statement.toUpperCase() + "!"; };

        var welcome = _.compose(greet, exclaim);

        welcome('moe');

        =&gt; 'hi: MOE!'


      </pre>

      <h2 id="objects">对象函数（Object Functions）</h2>

      <p id="keys">
        <b class="header">keys</b><code>_.keys(object)</code>
        <br> 检索
        <b>object</b>拥有的所有可枚举属性的名称。
      </p>
      <pre>_.keys({one: 1, two: 2, three: 3});

        =&gt; ["one", "two", "three"]


      </pre>

      <p id="allKeys">
        <b class="header">allKeys</b><code>_.allKeys(object)</code>
        <br> 检索
        <b>object</b>拥有的和继承的所有属性的名称。
      </p>
      <pre>
        function Stooge(name) {

        this.name = name;

      }

      Stooge.prototype.silly = true;

      _.allKeys(new Stooge("Moe"));

      =&gt; ["name", "silly"]


      </pre>

      <p id="values">
        <b class="header">values</b><code>_.values(object)</code>
        <br> 返回
        <b>object</b>对象所有的属性值。
      </p>
      <pre>_.values({one: 1, two: 2, three: 3});

        =&gt; [1, 2, 3]


      </pre>

      <p id="mapObject">
        <b class="header">mapObject</b><code>_.mapObject(object, iteratee, [context])</code>
        <br> 它类似于
        <a href="#map">map</a>，但是这用于对象。转换每个属性的值。
      </p>
      <pre>
        _.mapObject({start: 5, end: 12}, function(val, key) {

        return val + 5;

      });

      =&gt; {start: 10, end: 17}


      </pre>

      <p id="pairs">
        <b class="header">pairs</b><code>_.pairs(object)</code>
        <br> 把一个对象转变为一个
        <tt>[key, value]</tt>形式的数组。
      </p>
      <pre>_.pairs({one: 1, two: 2, three: 3});

        =&gt; [["one", 1], ["two", 2], ["three", 3]]


      </pre>

      <p id="invert">
        <b class="header">invert</b><code>_.invert(object)</code>
        <br> 返回一个
        <b>object</b>副本，使其键（keys）和值（values）对换。对于这个操作，必须确保object里所有的值都是唯一的且可以序列号成字符串.
      </p>
      <pre>_.invert({Moe: "Moses", Larry: "Louis", Curly: "Jerome"});

        =&gt; {Moses: "Moe", Louis: "Larry", Jerome: "Curly"};


      </pre>

      <p id="create">
        <b class="header">create</b><code>_.create(prototype, props)</code>
        <br> 创建具有给定原型的新对象， 可选附加
        <b>props</b> 作为 <i>own</i>的属性。 基本上，和
        <tt>Object.create</tt>一样， 但是没有所有的属性描述符。
      </p>
      <pre>var moe = _.create(Stooge.prototype, {name: "Moe"});


      </pre>

      <p id="object-functions">
        <b class="header">functions</b><code>_.functions(object)</code>
        <span class="alias">Alias: <b>methods</b></span>
        <br> 返回一个对象里所有的方法名, 而且是已经排序的 — 也就是说, 对象里每个方法(属性值是一个函数)的名称.
      </p>
      <pre>_.functions(_);

        =&gt; ["all", "any", "bind", "bindAll", "clone", "compact", "compose" ...


      </pre>

      <p id="findKey">
        <b class="header">findKey</b><code>_.findKey(object, predicate, [context])</code>
        <br> Similar to <a href="#findIndex"><tt>_.findIndex</tt></a> but for keys in objects. Returns the <i>key</i> where the <b>predicate</b> truth test passes or <i>undefined</i>.
      </p>

      <p id="extend">
        <b class="header">extend</b><code>_.extend(destination, *sources)</code>
        <br> 复制
        <b>source</b>对象中的所有属性覆盖到<b>destination</b>对象上，并且返回 <b>destination</b> 对象. 复制是按顺序的, 所以后面的对象属性会把前面的对象属性覆盖掉(如果有重复).
      </p>
      <pre>_.extend({name: 'moe'}, {age: 50});

        =&gt; {name: 'moe', age: 50}


      </pre>

      <p id="extendOwn">
        <b class="header">extendOwn</b><code>_.extendOwn(destination, *sources)</code>
        <span class="alias">Alias: <b>assign</b></span>
        <br> 类似于 <b>extend</b>, 但只复制<i>自己的</i>属性覆盖到目标对象。（注：不包括继承过来的属性）
      </p>

      <p id="pick">
        <b class="header">pick</b><code>_.pick(object, *keys)</code>
        <br> 返回一个
        <b>object</b>副本，只过滤出<b>keys</b>(有效的键组成的数组)参数指定的属性值。或者接受一个判断函数，指定挑选哪个key。
      </p>
      <pre>
        _.pick({name: 'moe', age: 50, userid: 'moe1'}, 'name', 'age');

        =&gt; {name: 'moe', age: 50}

        _.pick({name: 'moe', age: 50, userid: 'moe1'}, function(value, key, object) {

        return _.isNumber(value);

      });

      =&gt; {age: 50}


      </pre>

      <p id="omit">
        <b class="header">omit</b><code>_.omit(object, *keys)</code>
        <br> 返回一个
        <b>object</b>副本，只过滤出除去<b>keys</b>(有效的键组成的数组)参数指定的属性值。 或者接受一个判断函数，指定忽略哪个key。

      </p>
      <pre>_.omit({name: 'moe', age: 50, userid: 'moe1'}, 'userid');

        =&gt; {name: 'moe', age: 50}

        _.omit({name: 'moe', age: 50, userid: 'moe1'}, function(value, key, object) {

        return _.isNumber(value);

      });

      =&gt; {name: 'moe', userid: 'moe1'}


      </pre>

      <p id="defaults">
        <b class="header">defaults</b><code>_.defaults(object, *defaults)</code>
        <br> 用
        <b>defaults</b>对象填充<b>object</b> 中的<tt>undefined</tt>属性。 并且返回这个<b>object</b>。一旦这个属性被填充，再使用defaults方法将不会有任何效果。（感谢<a title="一任风月忆秋年" usercard="id=2654434300" href="http://weibo.com/u/2654434300">@一任风月忆秋年</a>的拍砖）
      </p>
      <pre>var iceCream = {flavor: "chocolate"};

        _.defaults(iceCream, {flavor: "vanilla", sprinkles: "lots"});

        =&gt; {flavor: "chocolate", sprinkles: "lots"}


      </pre>

      <p id="clone">
        <b class="header">clone</b><code>_.clone(object)</code>
        <br> 创建 一个浅复制（浅拷贝）的克隆<b>object</b>。任何嵌套的对象或数组都通过引用拷贝，不会复制。
      </p>
      <pre>_.clone({name: 'moe'});

        =&gt; {name: 'moe'};


      </pre>

      <p id="tap">
        <b class="header">tap</b><code>_.tap(object, interceptor)</code>
        <br> 用 <b>object</b>作为参数来调用函数<b>interceptor</b>，然后返回<b>object</b>。这种方法的主要意图是作为函数链式调用 的一环, 为了对此对象执行操作并返回对象本身。
      </p>
      <pre>_.chain([1,2,3,200])

        .filter(function(num) { return num % 2 == 0; })

        .tap(alert)

        .map(function(num) { return num * num })

        .value();

        =&gt; // [2, 200] (alerted)

        =&gt; [4, 40000]


      </pre>

      <p id="has">
        <b class="header">has</b><code>_.has(object, key)</code>
        <br> 对象是否包含给定的键吗？等同于
        <tt>object.hasOwnProperty(key)</tt>，但是使用<tt>hasOwnProperty</tt> 函数的一个安全引用，以防<a href="http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/">意外覆盖</a>。
      </p>
      <pre>_.has({a: 1, b: 2, c: 3}, "b");

        =&gt; true


      </pre>

      <p id="property">
        <b class="header">property</b><code>_.property(key)</code>
        <br> 返回一个函数，这个函数返回任何传入的对象的
        <tt>key</tt>属性。
      </p>
      <pre>var stooge = {name: 'moe'};

        'moe' === _.property('name')(stooge);

        =&gt; true


      </pre>

      <p id="propertyOf">
        <b class="header">propertyOf</b><code>_.propertyOf(object)</code>
        <br> 和
        <tt>_.property</tt>相反。需要一个对象，并返回一个函数,这个函数将返回一个提供的属性的值。
      </p>
      <pre>var stooge = {name: 'moe'};

        _.propertyOf(stooge)('name');

        =&gt; 'moe'
      </pre>

      <p id="matcher">
        <b class="header">matcher</b><code>_.matcher(attrs)</code>
        <br> 返回一个断言函数，这个函数会给你一个断言可以用来辨别给定的对象是否匹配
        <b>attrs</b>指定键/值属性。
      </p>
      <pre>var ready = _.matcher({selected: true, visible: true});

        var readyToGoList = _.filter(list, ready);
      </pre>

      <p id="isEqual">
        <b class="header">isEqual</b><code>_.isEqual(object, other)</code>
        <br> 执行两个对象之间的优化深度比较，确定他们是否应被视为相等。
      </p>
      <pre>var stooge = {name: 'moe', luckyNumbers: [13, 27, 34]};

        var clone  = {name: 'moe', luckyNumbers: [13, 27, 34]};

        stooge == clone;

        =&gt; false

        _.isEqual(stooge, clone);

        =&gt; true


      </pre>

      <p id="isMatch">
        <b class="header">isMatch</b><code>_.isMatch(object, properties)</code>
        <br> 告诉你
        <b>properties</b>中的键和值是否包含在<b>object</b>中。
      </p>
      <pre>var stooge = {name: 'moe', age: 32};

        _.isMatch(stooge, {age: 32});

        =&gt; true


      </pre>

      <p id="isEmpty">
        <b class="header">isEmpty</b><code>_.isEmpty(object)</code>
        <br> 如果
        <b>object</b> 不包含任何值(没有可枚举的属性)，返回<i>true</i>。 对于字符串和类数组（array-like）对象，如果length属性为0，那么
        <tt>_.isEmpty</tt>检查返回<i>true</i>。
      </p>
      <pre>_.isEmpty([1, 2, 3]);

        =&gt; false

        _.isEmpty({});

        =&gt; true


      </pre>

      <p id="isElement">
        <b class="header">isElement</b><code>_.isElement(object)</code>
        <br> 如果
        <b>object</b>是一个DOM元素，返回<i>true</i>。
      </p>
      <pre>_.isElement(jQuery('body')[0]);

        =&gt; true


      </pre>

      <p id="isArray">
        <b class="header">isArray</b><code>_.isArray(object)</code>
        <br> 如果
        <b>object</b>是一个数组，返回<i>true</i>。
      </p>
      <pre>(function(){ return _.isArray(arguments); })();

        =&gt; false

        _.isArray([1,2,3]);

        =&gt; true


      </pre>

      <p id="isObject">
        <b class="header">isObject</b><code>_.isObject(value)</code>
        <br> 如果
        <b>object</b>是一个对象，返回<i>true</i>。需要注意的是JavaScript数组和函数是对象，字符串和数字不是。

      </p>
      <pre>_.isObject({});

        =&gt; true

        _.isObject(1);

        =&gt; false


      </pre>

      <p id="isArguments">
        <b class="header">isArguments</b><code>_.isArguments(object)</code>
        <br> 如果
        <b>object</b>是一个参数对象，返回<i>true</i>。
      </p>
      <pre>(function(){ return _.isArguments(arguments); })(1, 2, 3);

        =&gt; true

        _.isArguments([1,2,3]);

        =&gt; false


      </pre>

      <p id="isFunction">
        <b class="header">isFunction</b><code>_.isFunction(object)</code>
        <br> 如果
        <b>object</b>是一个函数（Function），返回<i>true</i>。
      </p>
      <pre>_.isFunction(alert);

        =&gt; true


      </pre>

      <p id="isString">
        <b class="header">isString</b><code>_.isString(object)</code>
        <br> 如果
        <b>object</b>是一个字符串，返回<i>true</i>。
      </p>
      <pre>_.isString("moe");

        =&gt; true


      </pre>

      <p id="isNumber">
        <b class="header">isNumber</b><code>_.isNumber(object)</code>
        <br> 如果
        <b>object</b>是一个数值，返回<i>true</i> (包括 <tt>NaN</tt>)。
      </p>
      <pre>_.isNumber(8.4 * 5);

        =&gt; true


      </pre>

      <p id="isFinite">
        <b class="header">isFinite</b><code>_.isFinite(object)</code>
        <br> 如果
        <b>object</b>是一个有限的数字，返回<i>true</i>。
      </p>
      <pre>_.isFinite(-101);

        =&gt; true



        _.isFinite(-Infinity);

        =&gt; false


      </pre>

      <p id="isBoolean">
        <b class="header">isBoolean</b><code>_.isBoolean(object)</code>
        <br> 如果
        <b>object</b>是一个布尔值，返回<i>true</i>，否则返回<i>false</i>。
      </p>
      <pre>_.isBoolean(null);

        =&gt; false


      </pre>

      <p id="isDate">
        <b class="header">isDate</b><code>_.isDate(object)</code>
        <br> Returns <i>true</i> if <b>object</b> is a Date.
      </p>
      <pre>_.isDate(new Date());

        =&gt; true


      </pre>

      <p id="isRegExp">
        <b class="header">isRegExp</b><code>_.isRegExp(object)</code>
        <br> 如果
        <b>object</b>是一个正则表达式，返回<i>true</i>。
      </p>
      <pre>_.isRegExp(/moe/);

        =&gt; true


      </pre>

      <p id="isError">
        <b class="header">isError</b><code>_.isError(object)</code>
        <br> 如果
        <b>object</b>继承至 Error 对象，那么返回 <i>true</i>。
      </p>
      <pre>try {

        throw new TypeError("Example");

      } catch (o_O) {

      _.isError(o_O)

      }

      =&gt; true


      </pre>

      <p id="isNaN">
        <b class="header">isNaN</b><code>_.isNaN(object)</code>
        <br> 如果
        <b>object</b>是 <i>NaN</i>，返回<i>true</i>。
        <br> 注意： 这和原生的<b>isNaN</b> 函数不一样，如果变量是<i>undefined</i>，原生的<b>isNaN</b> 函数也会返回 <i>true</i> 。

      </p>
      <pre>_.isNaN(NaN);

        =&gt; true

        isNaN(undefined);

        =&gt; true

        _.isNaN(undefined);

        =&gt; false


      </pre>

      <p id="isNull">
        <b class="header">isNull</b><code>_.isNull(object)</code>
        <br> 如果
        <b>object</b>的值是 <i>null</i>，返回<i>true</i>。
      </p>
      <pre>_.isNull(null);

        =&gt; true

        _.isNull(undefined);

        =&gt; false


      </pre>

      <p id="isUndefined">
        <b class="header">isUndefined</b><code>_.isUndefined(value)</code>
        <br> 如果
        <b>value</b>是<i>undefined</i>，返回<i>true</i>。
      </p>
      <pre>_.isUndefined(window.missingVariable);

        =&gt; true


      </pre>

      <h2 id="utility">实用功能(Utility Functions) </h2>

      <p id="noConflict">
        <b class="header">noConflict</b><code>_.noConflict()</code>
        <br> 放弃
        <b>Underscore</b> 的控制变量"_"。返回<b>Underscore</b> 对象的引用。

      </p>
      <pre>var underscore = _.noConflict();


      </pre>

      <p id="identity">
        <b class="header">identity</b><code>_.identity(value)</code>
        <br> 返回与传入参数相等的值. 相当于数学里的: <tt>f(x) = x</tt>
        <br> 这个函数看似无用, 但是在Underscore里被用作默认的迭代器iterator.
      </p>
      <pre>var stooge = {name: 'moe'};

        stooge === _.identity(stooge);

        =&gt; true


      </pre>

      <p id="constant">
        <b class="header">constant</b><code>_.constant(value)</code>
        <br> 创建一个函数，这个函数 返回相同的值 用来作为
        <tt>_.constant</tt>的参数。
      </p>
      <pre>var stooge = {name: 'moe'};

        stooge === _.constant(stooge)();

        =&gt; true
      </pre>

      <p id="noop">
        <b class="header">noop</b><code>_.noop()</code>
        <br> 返回
        <tt>undefined</tt>，不论传递给它的是什么参数。 可以用作默认可选的回调参数。
      </p>
      <pre>obj.initialize = _.noop;


      </pre>

      <p id="times">
        <b class="header">times</b><code>_.times(n, iteratee, [context])</code>
        <br> 调用给定的迭代函数
        <b>n</b>次,每一次调用<b>iteratee</b>传递<tt>index</tt>参数。生成一个返回值的数组。
        <br>
        <i>注意: 本例使用 <a href="#chaining">链式语法</a></i>。
      </p>
      <pre>_(3).times(function(n){ genie.grantWishNumber(n); });
      </pre>

      <p id="random">
        <b class="header">random</b><code>_.random(min, max)</code>
        <br> 返回一个
        <b>min</b> 和 <b>max</b>之间的随机整数。如果你只传递一个参数，那么将返回<tt>0</tt>和这个参数之间的整数。
      </p>
      <pre>_.random(0, 100);

        =&gt; 42
      </pre>

      <p id="mixin">
        <b class="header">mixin</b><code>_.mixin(object)</code>
        <br> 允许用您自己的实用程序函数扩展Underscore。传递一个 <tt>{name: function}</tt>定义的哈希添加到Underscore对象，以及面向对象封装。
      </p>
      <pre>_.mixin({

        capitalize: function(string) {

        return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase();

      }

      });

      _("fabio").capitalize();

      =&gt; "Fabio"


      </pre>

      <p id="iteratee">
        <b class="header">iteratee</b><code>_.iteratee(value, [context])</code>
        <br> 一个重要的内部函数用来生成可应用到集合中每个元素的回调， 返回想要的结果 - 无论是等式，任意回调，属性匹配，或属性访问。
        <br> 通过
        <tt>_.iteratee</tt>转换判断的Underscore 方法的完整列表是
        <tt>map</tt>, <tt>find</tt>,
        <tt>filter</tt>, <tt>reject</tt>, <tt>every</tt>, <tt>some</tt>, <tt>max</tt>,
        <tt>min</tt>, <tt>sortBy</tt>, <tt>groupBy</tt>, <tt>indexBy</tt>,
        <tt>countBy</tt>, <tt>sortedIndex</tt>, <tt>partition</tt>, 和 <tt>unique</tt>.
      </p>
      <pre>var stooges = [{name: 'curly', age: 25}, {name: 'moe', age: 21}, {name: 'larry', age: 23}];

        _.map(stooges, _.iteratee('age'));

        =&gt; [25, 21, 23];


      </pre>

      <p id="uniqueId">
        <b class="header">uniqueId</b><code>_.uniqueId([prefix])</code>
        <br> 为需要的客户端模型或DOM元素生成一个全局唯一的id。如果
        <b>prefix</b>参数存在， id 将附加给它。
      </p>
      <pre>
        _.uniqueId('contact_');

        =&gt; 'contact_104'

      </pre>

      <p id="escape">
        <b class="header">escape</b><code>_.escape(string)</code>
        <br> 转义HTML字符串，替换
        <tt>&amp;</tt>, <tt>&lt;</tt>, <tt>&gt;</tt>, <tt>"</tt>, <tt>'</tt>, 和 <tt>/</tt>字符。
      </p>
      <pre>_.escape('Curly, Larry &amp; Moe');

        =&gt; "Curly, Larry &amp;amp; Moe"
      </pre>

      <p id="unescape">
        <b class="header">unescape</b><code>_.unescape(string)</code>
        <br> 和
        <a href="#escape"><b>escape</b></a>相反。转义HTML字符串，替换<tt>&amp;</tt>, <tt>&amp;lt;</tt>, <tt>&amp;gt;</tt>, <tt>&amp;quot;</tt>, <tt>&amp;#96;</tt>, 和 <tt>&amp;#x2F;</tt>字符。

      </p>
      <pre>_.unescape('Curly, Larry &amp;amp; Moe');

        =&gt; "Curly, Larry &amp; Moe"
      </pre>

      <p id="result">
        <b class="header">result</b><code>_.result(object, property, [defaultValue])</code>
        <br> 如果指定的
        <b>property</b> 的值是一个函数，那么将在<b>object</b>上下文内调用它;否则，返回它。如果提供默认值，并且属性不存在，那么默认值将被返回。如果设置<tt>defaultValue</tt>是一个函数，它的结果将被返回。
      </p>
      <pre>var object = {cheese: 'crumpets', stuff: function(){ return 'nonsense'; }};

        _.result(object, 'cheese');

        =&gt; "crumpets"

        _.result(object, 'stuff');

        =&gt; "nonsense"

        _.result(object, 'meat', 'ham');

        =&gt; "ham"


      </pre>

      <p id="now">
        <b class="header">now</b><code>_.now()</code>
        <br> 一个优化的方式来获得一个当前时间的整数时间戳。可用于实现定时/动画功能。
      </p>
      <pre>_.now();

        =&gt; 1392066795351


      </pre>

      <p id="template">
        <b class="header">template</b><code>_.template(templateString, [settings])</code>
        <br> 将 JavaScript 模板编译为可以用于页面呈现的函数, 对于通过JSON数据源生成复杂的HTML并呈现出来的操作非常有用。 模板函数可以使用
        <tt>&lt;%= … %&gt;</tt>插入变量, 也可以用<tt>&lt;% … %&gt;</tt>执行任意的 JavaScript 代码。 如果您希望插入一个值, 并让其进行HTML转义,请使用<tt>&lt;%- … %&gt;</tt>。 当你要给模板函数赋值的时候，可以传递一个含有与模板对应属性的
        <b>data</b>对象 。 如果您要写一个一次性的, 您可以传对象 <b>data</b> 作为第二个参数给模板 <b>template</b> 来直接呈现, 这样页面会立即呈现而不是返回一个模板函数. 参数 <b>settings</b> 是一个哈希表包含任何可以覆盖的设置 <tt>_.templateSettings</tt>.
      </p>

      <pre>var compiled = _.template("hello: &lt;%= name %&gt;");

        compiled({name: 'moe'});

        =&gt; "hello: moe"



        var template = _.template("&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;");

        template({value: '&lt;script&gt;'});

        =&gt; "&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;"
      </pre>

      <p>
        您也可以在JavaScript代码中使用 <tt>print</tt>. 有时候这会比使用 <tt>&lt;%= ... %&gt;</tt> 更方便.
      </p>

      <pre>var compiled = _.template("&lt;% print('Hello ' + epithet); %&gt;");

        compiled({epithet: "stooge"});

        =&gt; "Hello stooge"
      </pre>

      <p>如果ERB式的分隔符您不喜欢, 您可以改变Underscore的模板设置, 使用别的符号来嵌入代码.定义一个 <b>interpolate</b> 正则表达式来逐字匹配嵌入代码的语句, 如果想插入转义后的HTML代码则需要定义一个 <b>escape</b> 正则表达式来匹配,还有一个 <b>evaluate</b> 正则表达式来匹配您想要直接一次性执行程序而不需要任何返回值的语句.您可以定义或省略这三个的任意一个.例如, 要执行<a href="http://github.com/janl/mustache.js#readme">Mustache.js</a>类型的模板:
      </p>

      <pre>_.templateSettings = {

        interpolate: /\{\{(.+?)\}\}/g

      };



      var template = _.template("Hello {{ name }}!");

      template({name: "Mustache"});

      =&gt; "Hello Mustache!"
      </pre>

      <p>
        默认的, <b>template</b> 通过 <tt>with</tt> 语句来取得 data 所有的值. 当然, 您也可以在 <b>variable</b> 设置里指定一个变量名. 这样能显著提升模板的渲染速度.
      </p>

      <pre>_.template("Using 'with': &lt;%= data.answer %&gt;", {variable: 'data'})({answer: 'no'});

        =&gt; "Using 'with': no"
      </pre>

      <p>
        预编译模板对调试不可重现的错误很有帮助. 这是因为预编译的模板可以提供错误的代码行号和堆栈跟踪, 有些模板在客户端(浏览器)上是不能通过编译的 在编译好的模板函数上, 有 <b>source</b> 属性可以提供简单的预编译功能.
      </p>

      <pre>&lt;script&gt;

        JST.project = &lt;%= _.template(jstText).source %&gt;;

        &lt;/script&gt;
      </pre>

      <h2 id="chaining">链式语法(Chaining)</h2>

      <p>
        您可以在面向对象或者函数的风格下使用Underscore, 这取决于您的个人偏好. 以下两行代码都可以 把一个数组里的所有数字乘以2.
      </p>

      <pre>_.map([1, 2, 3], function(n){ return n * 2; });

        _([1, 2, 3]).map(function(n){ return n * 2; });
      </pre>

      <p>
        对一个对象使用 <tt>chain</tt> 方法, 会把这个对象封装并 让以后每次方法的调用结束后都返回这个封装的对象, 当您完成了计算, 可以使用 <tt>value</tt> 函数来取得最终的值. 以下是一个同时使用了 <b>map/flatten/reduce</b> 的链式语法例子, 目的是计算一首歌的歌词里每一个单词出现的次数.
      </p>

      <pre>var lyrics = [

        {line: 1, words: "I'm a lumberjack and I'm okay"},

        {line: 2, words: "I sleep all night and I work all day"},

        {line: 3, words: "He's a lumberjack and he's okay"},

        {line: 4, words: "He sleeps all night and he works all day"}

        ];



        _.chain(lyrics)

        .map(function(line) { return line.words.split(' '); })

        .flatten()

        .reduce(function(counts, word) {

        counts[word] = (counts[word] || 0) + 1;

        return counts;

      }, {})

      .value();



      =&gt; {lumberjack: 2, all: 4, night: 2 ... }
      </pre>

      <p>
        In addition, the 此外, <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/prototype">数组原型方法</a> 也通过代理加入到了链式封装的Underscore对象, 所以您可以 在链式语法中直接使用 <tt>reverse</tt> 或 <tt>push</tt> 方法, 然后再接着其他的语句.
      </p>

      <p id="chain">
        <b class="header">chain</b><code>_.chain(obj)</code>
        <br> 返回一个封装的对象. 在封装的对象上调用方法会返回封装的对象本身, 直道 <tt>value</tt> 方法调用为止.
      </p>
      <pre>var stooges = [{name: 'curly', age: 25}, {name: 'moe', age: 21}, {name: 'larry', age: 23}];

        var youngest = _.chain(stooges)

        .sortBy(function(stooge){ return stooge.age; })

        .map(function(stooge){ return stooge.name + ' is ' + stooge.age; })

        .first()

        .value();

        =&gt; "moe is 21"


      </pre>

      <p id="value">
        <b class="header">value</b><code>_(obj).value()</code>
        <br> 获取封装对象的最终值.
      </p>
      <pre>_([1, 2, 3]).value();

        =&gt; [1, 2, 3]


      </pre>

      </div>

    </div>
  </body>
  <script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
  <script type="text/javascript">
    $(function(){
      $(".toc_title").click(function(){
        $(this).next().slideToggle(1000);
      });
    })
  </script>
</html>

